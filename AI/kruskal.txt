3)KRUSKALS
def find(parent, x):
    if parent[x] != x:
        parent[x] = find(parent, parent[x])
    return parent[x]

def union(parent, rank, x, y):
    rootX = find(parent, x)
    rootY = find(parent, y)
    if rank[rootX] < rank[rootY]:
        parent[rootX] = rootY
    elif rank[rootX] > rank[rootY]:
        parent[rootY] = rootX
    else:
        parent[rootY] = rootX
        rank[rootX] += 1

def kruskal(edges, V):
    edges.sort(key=lambda x: x[2])
    parent = [i for i in range(V)]
    rank = [0] * V
    mst = []
    
    for u, v, w in edges:
        if find(parent, u) != find(parent, v):
            mst.append([u, v, w])
            union(parent, rank, u, v)  # pass nodes, not roots

        if len(mst) == V-1:
            break

    return mst

# Input
V = int(input("Enter number of vertices: "))
E = int(input("Enter number of edges: "))
edges = []
print("Enter edges as: u v weight")
for _ in range(E):
    u, v, w = map(int, input().split())
    edges.append([u, v, w])

mst = kruskal(edges, V)
print("\nEdges in MST:")
for u, v, w in mst:
    print(f"{u} - {v} : {w}")

Union-Find Functions:
#find(parent, x): Returns the root of the set containing x (with path compression to #optimize).
#union(parent, rank, x, y): Joins two sets if they are disjoint, using rank optimization to #keep trees shallow.
#Sort the Edges:
#edges.sort(key=lambda x: x[2]) sorts all edges by their weight in ascending order.
#Build MST:
#Loop through edges.
#If adding an edge doesnâ€™t form a cycle (find(u) != find(v)), add it to MST.
#Use union to combine sets of connected vertices.
#Stop Condition:
#MST is complete when it has V-1 edges, where V is the number of vertices.
#Output:
#Prints all edges included in the MST and their weights.

Enter number of vertices: 4
Enter number of edges: 5
Edges:
0 1 10
0 2 6
0 3 5
1 3 15
2 3 4